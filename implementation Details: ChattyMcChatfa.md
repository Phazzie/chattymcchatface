# Implementation Details: ChattyMcChatface

This document contains the technical specifications, architecture decisions, and implementation notes derived from the project plan.

## Step 1: Project Setup & Basic Extension Structure

### 1. Testing Strategy

- **Unit test specifications:** None strictly needed for boilerplate, but could add a test to ensure the extension activates (`extension.ts`).
- **Integration test cases:** Run the default "Hello World" extension test generated by `yo code` to ensure the basic testing framework and extension activation work correctly within VS Code.
- **Testing rationale and coverage goals:** Verify the fundamental extension setup, activation, and the test runner configuration. Goal: Ensure the core extension loads and basic commands can run.
- **Test dependencies and mocks needed:** VS Code Extension Test framework (`@vscode/test-electron`).

### 2. File Creation

- `package.json`: (Generated) Defines extension metadata, dependencies, activation events, and commands. (Responsibilities: 1 - Configuration/Metadata)
- `src/extension.ts`: (Generated) The main entry point for the extension, containing `activate` and `deactivate` functions. (Responsibilities: 1 - Extension lifecycle management)
- `tsconfig.json`: (Generated) TypeScript compiler configuration. (Responsibilities: 1 - Build configuration)
- `.vscodeignore`, `CHANGELOG.md`, `README.md`, `src/test/suite/extension.test.ts`, `src/test/suite/index.ts`, `src/test/runTest.ts`: (Generated) Standard files for ignore patterns, version history, description, and test setup. (Responsibilities: 1 each - Specific utility/documentation/testing roles)
- **SRP Compliance:** All generated files generally adhere to SRP, handling distinct aspects like configuration, activation, testing, etc.

### 3. Code Quality Analysis

- **SOLID:** N/A (Boilerplate code, minimal logic).
- **KISS:** Yes, the generated structure is standard and relatively simple.
- **DRY:** N/A (Boilerplate code).
- **Component interactions:** `extension.ts` is activated by VS Code based on `package.json` events. Test runner executes tests in `src/test/suite/`.
- **Edge cases:** Incorrect Node.js/VS Code versions (handled by `engines` in `package.json`), generator errors.
- **Performance:** N/A (Minimal activation code).

---

## Step 2: Network Discovery & Connection Setup (using UDP Broadcast)

### 1. Testing Strategy

- **Unit test specifications:**
    - Test parsing of broadcast messages.
    - Test creation of broadcast message payload.
    - Mock `dgram` to test socket binding, sending, and receiving logic without actual network traffic.
    - Test logic for initiating a TCP connection upon successful discovery.
- **Integration test cases:** Run two instances of the extension on the same machine or network. Verify that one instance broadcasting triggers a discovery event and connection attempt on the other. Test connection establishment.
- **Testing rationale and coverage goals:** Ensure the discovery mechanism (sending/receiving broadcasts) works reliably and that a connection is attempted upon discovery. Goal: Cover core discovery logic and connection initiation.
- **Test dependencies and mocks needed:** Mocking library (e.g., `jest.mock` or `sinon`), potentially mock `dgram` and `net` modules.

### 2. File Creation

- `src/networkManager.ts`: Handles network discovery (UDP broadcast) and establishing/managing the primary peer-to-peer connection (TCP socket). (Responsibilities: 2 - Discovery and Connection Management. Justification: These are closely related aspects of establishing peer communication; separating further might lead to overly fragmented logic at this stage, but could be revisited if complexity grows).
- `src/constants.ts`: Stores constants like broadcast port, connection port, message identifiers. (Responsibilities: 1 - Define application constants).

### 3. Code Quality Analysis

- **SOLID:**
    - SRP: `networkManager.ts` has two responsibilities (Discovery, Connection). Monitor if this becomes complex. If so, split into `discovery.ts` and `connection.ts`. O: Designed to be extensible (e.g., different discovery methods). L/I/D: Less applicable at this stage, but interfaces for connection/discovery events could be defined.
- **KISS:** UDP broadcast is relatively simple but less reliable than mDNS. TCP connection logic is standard. Avoid overly complex state management initially.
- **DRY:** Consolidate network configuration (ports, addresses) in `constants.ts`. Ensure broadcast sending/listening logic isn't duplicated.
- **Component interactions:** `extension.ts` will instantiate and use `NetworkManager`. `NetworkManager` uses `dgram` for UDP and `net` for TCP.
- **Edge cases:** No peer found, multiple peers responding (select first?), broadcast blocked by firewall, port conflicts (use error handling and potentially configurable ports), network errors during connection, connection refused.
- **Performance:** UDP broadcast is lightweight. TCP connection overhead is minimal for one connection.

---

## Step 3: Authentication/Pairing ("Animal Names")

### 1. Testing Strategy

- **Unit test specifications:**
    - Test the generation/formatting of the authentication challenge/response.
    - Test the validation logic comparing received animal names against expected ones.
    - Mock the connection interface to simulate sending/receiving auth messages.
- **Integration test cases:** After connection establishment (from Step 2), test the full auth flow: one side sends challenge (e.g., "Enter my 3 animals"), the other sends response, connection proceeds only if names match. Test mismatched names scenario.
- **Testing rationale and coverage goals:** Ensure the simple shared secret mechanism correctly authenticates the peer before allowing further communication. Goal: Cover auth message exchange and validation logic.
- **Test dependencies and mocks needed:** Mock connection object/interface.

### 2. File Creation

- `src/authHandler.ts`: Manages the "animal names" authentication protocol over an established connection. (Responsibilities: 1 - Handle authentication sequence).
- _(Modify)_ `src/networkManager.ts`: Integrate `AuthHandler` to perform authentication after a raw TCP connection is established before signalling 'connection ready'. (Adds responsibility: Orchestrating post-connection auth).

### 3. Code Quality Analysis

- **SOLID:**
    - SRP: `AuthHandler` focuses solely on the auth protocol. `NetworkManager` delegates auth, maintaining its core focus on connection lifecycle.
- **KISS:** The "animal names" approach is very simple. The implementation should reflect this, avoiding complex state machines for this step.
- **DRY:** Ensure the logic for comparing animal names is centralized.
- **Component interactions:** `NetworkManager` creates/uses `AuthHandler` instance per connection. `AuthHandler` uses the connection socket (provided by `NetworkManager`) to exchange messages. `NetworkManager` waits for success/failure signal from `AuthHandler`.
- **Edge cases:** Connection drops during auth, timeout waiting for response, incorrect animal names entered, case sensitivity issues (decide on handling - likely ignore case), user cancels input.
- **Performance:** Negligible impact.

---

## Step 4: Webview UI Panel

### 1. Testing Strategy

- **Unit test specifications:**
    - Test JavaScript functions within the webview for message formatting, DOM manipulation (adding messages, clearing input).
    - Test message passing logic between the webview and the extension host (mocking `vscode.postMessage` and message event listeners).
- **Integration test cases:** Open the webview panel in VS Code. Verify UI elements render correctly. Test sending a message from the input field triggers an event in the extension host. Test sending a message _to_ the webview from the extension host correctly displays it in the chat area.
- **Testing rationale and coverage goals:** Ensure the UI components are created, messages can be sent from the UI, and messages received from the peer can be displayed. Goal: Cover UI rendering and bidirectional communication between webview and extension host.
- **Test dependencies and mocks needed:** Mock `vscode` API (`acquireVsCodeApi`, `postMessage`) for webview-side JS tests. JSDOM or similar for testing DOM manipulation outside a real browser/webview.

### 2. File Creation

- `src/webviewProvider.ts`: Manages the lifecycle and content of the VS Code Webview panel. (Responsibilities: 1 - Webview lifecycle and communication bridge).
- `webview/index.html`: Basic HTML structure for the chat panel (message display area, input box, send button). (Responsibilities: 1 - UI Structure).
- `webview/style.css`: CSS rules for styling the chat panel. (Responsibilities: 1 - UI Styling).
- `webview/main.js`: JavaScript running inside the webview to handle user input (sending messages) and display incoming messages. (Responsibilities: 1 - UI Logic and Extension Communication).

### 3. Code Quality Analysis

- **SOLID:**
    - SRP: `WebviewProvider` manages the VS Code panel integration. `main.js` handles the UI logic within the panel. HTML/CSS handle structure/style. Clear separation.
- **KISS:** Start with minimal HTML/CSS/JS. Avoid complex frameworks inside the webview for this simple case unless necessary. Use basic DOM manipulation.
- **DRY:** Use CSS classes effectively. Centralize message posting logic in `main.js`.
- **Component interactions:** `extension.ts` registers and shows the `WebviewProvider`. `WebviewProvider` creates the Webview panel and sets its HTML content. `WebviewProvider` communicates with `webview/main.js` using `postMessage` and `onDidReceiveMessage`. `main.js` interacts with the HTML DOM.
- **Edge cases:** Panel closed by user, VS Code window resized, large number of messages impacting performance (consider virtualization later if needed), script errors in webview JS, content security policy blocking resources.
- **Performance:** Minimal impact for basic chat. DOM manipulation for many messages could slow down; optimize if it becomes an issue.

---

## Step 5: Message Sending & Receiving Logic

### 1. Testing Strategy

- **Unit test specifications:**
    - Test message serialization/deserialization logic (if any structure is added beyond plain text).
    - Mock the connection socket to test sending data.
    - Mock the connection socket's 'data' event to test receiving and parsing incoming messages.
    - Test the routing logic: `NetworkManager` receives data -> notifies main logic -> `WebviewProvider` -> `webview/main.js`.
    - Test the reverse routing: `webview/main.js` -> `WebviewProvider` -> main logic -> `NetworkManager` sends data.
- **Integration test cases:** Run two connected and authenticated extension instances. Send a message from one instance's webview and verify it appears in the other instance's webview. Test sending messages in both directions.
- **Testing rationale and coverage goals:** Ensure messages typed by the user are correctly transmitted over the network connection and messages received over the network are correctly displayed in the UI. Goal: Cover the end-to-end message flow.
- **Test dependencies and mocks needed:** Mock connection socket/interface, mock `WebviewProvider` interface/methods.

### 2. File Creation

- _(Modify)_ `src/extension.ts`: Orchestrate the components: listen for messages from `WebviewProvider` to send via `NetworkManager`, and listen for messages from `NetworkManager` to display via `WebviewProvider`. (Adds responsibility: Core message routing logic).
- _(Modify)_ `src/networkManager.ts`: Add methods to send message data over the active connection and emit events when message data is received.
- _(Modify)_ `src/webviewProvider.ts`: Add methods/events to facilitate sending messages _to_ the extension host (from user input) and receiving messages _from_ the extension host (to display).

### 3. Code Quality Analysis

- **SOLID:**
    - SRP: `extension.ts` acts as a mediator, which is acceptable for simple cases but could become a God object if too much logic accumulates. Consider dedicated `messageRouter.ts` if complexity increases. `NetworkManager` handles raw sending/receiving. `WebviewProvider` handles UI updates.
- **KISS:** Use a simple message format (e.g., newline-delimited strings or simple JSON) initially. Avoid complex buffering unless needed.
- **DRY:** Centralize message handling logic. Avoid duplicating send/receive logic between `NetworkManager` and `extension.ts`.
- **Component interactions:** `Webview` -> `WebviewProvider` -> `extension.ts` -> `NetworkManager` -> Socket -> Peer `NetworkManager` -> Peer `extension.ts` -> Peer `WebviewProvider` -> Peer `Webview`.
- **Edge cases:** Network errors during send/receive, connection closed unexpectedly, large messages (potential fragmentation or blocking - TCP handles fragmentation, but large messages might need chunking/streaming later), message encoding issues (use UTF-8 consistently), messages arriving out of order (TCP guarantees order).
- **Performance:** Should be fine for typical chat messages. Very high message rates could require optimization.
